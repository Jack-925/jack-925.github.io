---
layout: post
comments: true
categories: algorithm
tags: [java,bit operation]
---

计算机组成原理的时候都学过，不过有点生疏了，最近在研究hashcode的时候遇到又重新整理复习了以下。贴在此处给大家观看也方便自己以后查阅~

# 位运算bit operation：
`and运算& （按位与）` ： a & b  1&1=1，0&0=0 , 0&1=0 
`or运算 |  （按位或）` ： 1 | 1 = 1,     1 | 0 = 1,    0 | 0=0 
`xor运算 ^ (按位异或） `exclusive or ,数学符号为“⊕”，计算机符号为“eor”：
1 ^ 1 = 0  , 1 ^ 0 = 1,  0^ 0=0 
 (不同就是1，相同就是0）

`a >> b `带符号右移 ：
- 当a为正数时： 将a右移b位，在高位（左边）补0  ，例如：23 >> 2  =5：
 23的二进制表示为 10111，右移2位后变为 00101，00101的十进制就是5。
注：23是int类型，Java中表示为32位，实际在计算机中记录为 00000000 00000000 00000000 00010111

- 当a为负数时，将a右移b位，在高位（左边）补1 ，例如 -23 >> 2 = -6：
-23在计算机中以其补码形式存在 11111111 11111111 11111111  11101001
右移2位后变为 11111111 11111111 11111111  11111010 其对应的10进制数字就是-6
（关于补码忘记了的可以滑到下面看~）

`a>>> b  `无符号右移：
就是a无论是正数还是负数将其右移b位后，高位补零。

需要注意的是负数右移在高位补0相当于位数减少了并且变成了正数，因为第一位符号位变成了0表示正数。


`number << n`
带符号左移，无论对于正数还是负数，都是在低位补零。
对于正数相当于 乘以了2^n

==不存在 <<< 无符号左移！==

# 关于原码，反码，补码
`原码：`
原码就是符号位加上真值的绝对值, 即用第一位表示符号（0为正，1为负）, 其余位表示值
[+1]原 = 0000 0001
[-1]原 = 1000 0001


`反码`
正数的反码是其本身
负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。(1变0，0变1）

`补码：`
- 正整数的补码与原码相同。 例如在8位二进制表示中，
+23 = 00010111 ，


- 负整数的补码，将其反码+1。例如（在8位二进制的表示中）
1、-23 的原码对应 带符号位1的23 ： 10010111 
2、 其反码：除符号位外按位取反： 11101000 
3、 最后+1 ：  11101001

数0的补码表示是唯一的：
[+0]补=[+0]反=[+0]原=00000000
[ -0]补=11111111+1=00000000

==计算机中的加减法都是利用补码来计算的！==